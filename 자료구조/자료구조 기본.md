# 알고리즘/Complexity

- 선형 자료구조
    - 스택 : LIFO(Last In First Out) 형식의 자료구조 (후입선출)
    - 큐 : FIFO(First In First Out) 형식의 자료구조 (선입선출)
    - 데크
        - 삽입 삭제가 양쪽에서 일어날 수 있는 자료구조
        - 스택 & 큐의 장점만 뽑아간 자료구조
- 비선형 자료구조
    - 트리
- 정렬 알고리즘
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/743a874f-d1a9-4d2b-b0f6-e3f0ad0528d7/Untitled.png)
    
    - 퀵 정렬
        - 피봇(키 값)을 정한 후 그를 기준으로 왼쪽에서부터 피봇보다 큰 숫자를 찾고, 찾은 후에 오른쪽부터 작은 숫자를 찾은 후 두 숫자를 스왑하여 이 작업을 반복하면, 피봇을 기준으로 작은 숫자 배열과 큰 숫자 배열로 나누어지게 된다. 이 작업을 반복하면 퀵정렬이 완성된다.
        - 퀵 정렬 코드
            
            ```jsx
            function Quick(data, l, r){
                let left = 1;
                let right = r;
                let pivot = data[(i + r) / 2];
            
                do{
                    while(data[left] < pivot) left++;
                    while(data[right] > pivot) right--;
            
                    if(left <= right){    
                        let temp = data[left];
                        data[left] = data[right];
                        data[right] = temp;
                        left++;
                        right--;
                    }   
                } while (left <= right);
                
                if(l < right) Quick(data, l, right);
                if(r > left) Quick(data, left, r);
            }
            ```
            
    
    - 선택정렬
        - 처음에 들어갈 숫자를 선택한다. 앞에서부터 탐색하여 끝까지 탐색하는 도중 선택한 숫자보다 작은 숫자 발견시 그 숫자와 스왑하여 가장 작은 수부터 정렬한다.
    - 삽입정렬
        - 앞에서부터 비교하여 자신보다 큰 숫자가 앞에 있을시 그 사이에 삽입한다. 이를 반복하면 정렬이 완성된다.
    - 버블정렬
        - 앞에서부터 자신과 뒤의 숫자를 비교하여 자신의 더 작을시 스왑하여 큰 숫자는 가장 뒤로 밀리게 된다. 이를 반복하면, 정렬이 완성된다.
        
        [참고:[https://sabarada.tistory.com/138](https://sabarada.tistory.com/138)]
        
        **Arrays.sort()** : 듀얼피봇 퀵정렬(Dual-Pivot QuickSort), 일반적인 퀵 정렬과는 다르게 피봇을 2개를 두고 3개의 구간을 만들어 퀵정렬을 진행한다. 이 정렬방식은 랜덤 데이터에 대해서 평균적으로 퀵소트보다 좋은 성능을 낸다.
        
        **Collections.sort()** : 레거시로 합병정렬과 Tim 정렬을 사용하고 있다. Tim 정렬은 삽입(Insertion) 정렬과 합병(Merge) 정렬을 결합하여 만든 정렬이다.
        
        Arrays.sort() vs Collections.sort()
        
        ⇒ Collection은 List를 기준으로 봤을 때 메모리간 인접한 ArrayList 뿐 만 아니라 메모리적으로 산발적인 LinkedList도 함께 존재합니다. 따라서 참조 인접성이 좋지 않고 C의 값이 상대적으로 높다고 합니다. 이럴 때는 퀵 정렬 보다는 합병정렬과 삽입정렬을 병합한 Tim 정렬을 이용하는 게 평균적으로 더 좋은 성능을 기대할 수 있다고 합니다.